<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Happy Farm 2000</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: #1a3a1a;
        }

        #game {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Game world - fixed size, background never crops */
        #game-world {
            position: absolute;
            width: 1200px;
            height: 900px;
            left: 50%;
            top: 50%;
            margin-left: -600px;
            margin-top: -450px;
            background: url('fsm/ui/background.jpg') no-repeat;
            background-size: 100% 100%;
        }

        /* Top Left Stats */
        .top-left-stats {
            position: fixed;
            top: 10px;
            left: 10px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
            z-index: 100;
        }

        .level-circle {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            border: 4px solid #81C784;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }

        .stats-column {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .user-panel {
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.9), rgba(101, 67, 33, 0.9));
            border: 3px solid #8B4513;
            border-radius: 12px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #FFD700;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
        }

        .user-info {
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .username {
            font-weight: bold;
            font-size: 16px;
        }

        .user-level {
            font-size: 12px;
            color: #FFD700;
        }

        .resources {
            position: fixed;
            top: 70px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
        }

        .resource {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.5));
            border: 2px solid #666;
            border-radius: 20px;
            padding: 6px 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .resource.silver {
            border-color: #C0C0C0;
        }

        .resource.gold {
            border-color: #FFD700;
        }

        /* Right sidebar buttons (vertical) */
        .right-sidebar {
            position: fixed;
            right: 10px;
            top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .sidebar-btn {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }

        .sidebar-btn:hover {
            transform: scale(1.1);
        }

        .sidebar-btn.cyan {
            background: linear-gradient(135deg, #4DD0E1, #00ACC1);
        }

        .sidebar-btn.green {
            background: linear-gradient(135deg, #81C784, #4CAF50);
        }

        .sidebar-btn.orange {
            background: linear-gradient(135deg, #FFB74D, #FF9800);
        }

        .sidebar-btn.red {
            background: linear-gradient(135deg, #E57373, #F44336);
        }

        .sidebar-btn.yellow {
            background: linear-gradient(135deg, #FFF176, #FFEB3B);
        }

        /* Bottom toolbar with labels */
        .bottom-toolbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: transparent;
            padding: 8px 10px 12px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
        }

        .toolbar-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .toolbar-item:hover {
            transform: translateY(-3px);
        }

        .toolbar-item .icon {
            width: 50px;
            height: 50px;
            border-radius: 14px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            backdrop-filter: blur(4px);
        }

        .toolbar-item .icon.active {
            background: rgba(76, 175, 80, 0.5);
            border-color: #4CAF50;
        }

        .toolbar-item .label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .farm-container {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 400px;
        }

        .farm-grid {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .plot {
            position: absolute;
            width: 100px;
            height: 60px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .plot:hover {
            filter: brightness(1.2);
            /* z-index: 10; */
        }

        .plot .crop-img {
            position: absolute;
            width: 150px;
            height: auto;
            bottom: 17px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }

        .plot .stage-indicator {
            position: absolute;
            bottom: 5px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 8px;
            z-index: 10;
        }

        .plot .countdown-timer {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background: rgba(76, 175, 80, 0.85);
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 8px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 3px;
            z-index: 10;
        }

        .plot .countdown-timer.warning {
            background: rgba(255, 152, 0, 0.85);
        }

        .plot .countdown-timer.danger {
            background: rgba(244, 67, 54, 0.85);
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }


        /* Map Objects (Factories, Animals, Buildings) */
        .map-object {
            position: absolute;
            cursor: pointer;
            transition: transform 0.2s;
            /* z-index: 50; */
        }

        .map-object:hover {
            filter: brightness(1.1);
        }

        .map-object .object-icon {
            font-size: 70px;
            filter: drop-shadow(3px 5px 8px rgba(0, 0, 0, 0.6));
        }

        .map-object .object-label {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: bold;
        }

        /* Animals Container */
        #animals-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .animal-object {
            position: absolute;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.3s ease;
        }

        .animal-object:hover {
            transform: scale(1.1);
            filter: brightness(1.15);
        }

        .animal-object .animal-icon {
            filter: drop-shadow(3px 5px 8px rgba(0, 0, 0, 0.5));
        }

        .animal-object .animal-icon img,
        .animal-object .animal-icon video {
            width: 100px;
            height: auto;
            border-radius: 8px;
        }

        .animal-object .animal-icon video {
            object-fit: cover;
        }

        .animal-object .animal-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.9), rgba(101, 67, 33, 0.9));
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: bold;
            border: 2px solid rgba(255, 215, 0, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .animal-object .animal-status {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .animal-object .animal-status.hungry {
            background: #FF9800;
        }

        .animal-object .animal-status.sick {
            background: #F44336;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            /* z-index: 1000; */
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #f0f0f0;
            border-radius: 12px;
            max-width: 450px;
            width: 95%;
            max-height: 85vh;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #4a4a4a;
            color: white;
        }

        .modal-title {
            font-size: 18px;
            font-weight: bold;
        }

        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.8;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .modal-body {
            padding: 16px;
            overflow-y: auto;
            max-height: calc(85vh - 100px);
            background: #e8e8e8;
        }

        .modal-footer {
            padding: 12px 16px;
            background: #d0d0d0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #bbb;
        }

        .modal-footer .total-price {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            color: #333;
        }

        .modal-footer .btn-action {
            background: linear-gradient(135deg, #4CAF50, #388E3C);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
        }

        .modal-footer .btn-action:hover {
            background: linear-gradient(135deg, #66BB6A, #43A047);
        }

        /* Item grid */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
        }

        .shop-item {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .shop-item:hover {
            border-color: #4CAF50;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .shop-item-icon {
            font-size: 40px;
            margin-bottom: 6px;
        }

        .shop-item-icon img {
            width: 50px;
            height: auto;
        }

        .shop-item-name {
            font-size: 12px;
            color: #333;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .shop-item-price {
            font-size: 11px;
            color: #FF9800;
            font-weight: bold;
        }

        .shop-item-qty {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #4CAF50;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }

        /* Quantity selector */
        .qty-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
        }

        .qty-selector button {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: #4a4a4a;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }

        .qty-selector button:hover {
            background: #666;
        }

        .qty-selector input {
            width: 40px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px;
            font-size: 14px;
        }

        /* Submodal (confirmation dialog) */
        .submodal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .submodal.active {
            display: flex;
        }

        .submodal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 320px;
            width: 90%;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .submodal-icon {
            font-size: 40px;
            margin-bottom: 12px;
        }

        .submodal-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }

        .submodal-text {
            font-size: 14px;
            color: #666;
            margin-bottom: 16px;
        }

        .submodal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .submodal-buttons button {
            padding: 10px 24px;
            border: 2px solid #4a90d9;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }

        .submodal-buttons .btn-ok {
            background: #4a90d9;
            color: white;
        }

        .submodal-buttons .btn-cancel {
            background: white;
            color: #4a90d9;
        }

        /* Exp Bar */
        .exp-bar {
            position: absolute;
            top: 70px;
            left: 10px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 2px solid #9C27B0;
            overflow: hidden;
        }

        .exp-fill {
            height: 100%;
            background: linear-gradient(90deg, #9C27B0, #E040FB);
            width: 35%;
        }

        .exp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        /* Optimistic Harvest Animations */
        .harvest-popup {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.95), rgba(56, 142, 60, 0.95));
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 16px;
            animation: harvestFloat 1s ease-out forwards;
            z-index: 100;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        @keyframes harvestFloat {
            0% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }

            50% {
                opacity: 1;
                transform: translateX(-50%) translateY(-25px) scale(1.1);
            }

            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-50px) scale(0.9);
            }
        }

        .plot.harvesting {
            animation: harvestPulse 0.4s ease-out;
        }

        @keyframes harvestPulse {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.15);
                filter: brightness(1.3);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .plot.pending {
            opacity: 0.7;
            pointer-events: none;
        }

        .plot.error {
            animation: errorShake 0.5s ease-out;
        }

        @keyframes errorShake {

            0%,
            100% {
                transform: translateX(0);
            }

            20%,
            60% {
                transform: translateX(-5px);
            }

            40%,
            80% {
                transform: translateX(5px);
            }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            z-index: 3000;
            animation: toastSlide 0.3s ease-out;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            max-width: 90%;
            text-align: center;
        }

        .toast.error {
            background: linear-gradient(135deg, #F44336, #D32F2F);
        }

        .toast.success {
            background: linear-gradient(135deg, #4CAF50, #388E3C);
        }

        .toast.warning {
            background: linear-gradient(135deg, #FF9800, #F57C00);
        }

        @keyframes toastSlide {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes toastFadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <div id="game">
        <!-- Game World (scales with background) -->
        <div id="game-world">
            <!-- Factories/Buildings layer (behind plots) -->
            <div id="factories-layer"></div>
            <!-- Animals layer -->
            <div id="animals-layer"></div>
            <!-- Farm Grid (in front) -->
            <div class="farm-container">
                <div class="farm-grid" id="farm-grid"></div>
            </div>
        </div>

        <!-- UI Layer (fixed to screen) -->
        <!-- Top Left Stats -->
        <div class="top-left-stats">
            <div class="level-circle" id="level-circle">50</div>
            <div class="stats-column">
                <div class="resource silver"><span>ü™ô</span><span id="silver">1,250</span></div>
                <div class="resource gold"><span>üíé</span><span id="gold">50</span></div>
            </div>
        </div>

        <!-- Right Sidebar (vertical buttons) -->
        <div class="right-sidebar">
            <div class="sidebar-btn cyan" onclick="showModal('settings')">‚öôÔ∏è</div>
            <div class="sidebar-btn green" onclick="showModal('friends')">üë•</div>
            <div class="sidebar-btn orange" onclick="showModal('achievements')">üèÜ</div>
            <div class="sidebar-btn red" onclick="showModal('notifications')">üîî</div>
        </div>

        <!-- Bottom Toolbar -->
        <div class="bottom-toolbar">
            <div class="toolbar-item" id="seed-selector" onclick="openSeedSelector()">
                <div class="icon" id="selected-seed-icon">üå±</div>
                <span class="label" id="selected-seed-name">–°–µ–º–µ–Ω–∞</span>
            </div>
            <div class="toolbar-item" onclick="showModal('warehouse')">
                <div class="icon">üì¶</div>
                <span class="label">–°–∫–ª–∞–¥</span>
            </div>
            <div class="toolbar-item" onclick="showModal('shop')">
                <div class="icon">üõí</div>
                <span class="label">–ú–∞–≥–∞–∑–∏–Ω</span>
            </div>
            <div class="toolbar-item" onclick="showModal('friends')">
                <div class="icon">üë®‚Äçüåæ</div>
                <span class="label">–§–µ—Ä–º–µ—Ä—ã</span>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title" id="modal-title"></span>
                <button class="modal-close" onclick="closeModal()">√ó</button>
            </div>
            <div class="modal-body" id="modal-body"></div>
            <div class="modal-footer" id="modal-footer" style="display:none">
                <div class="total-price">
                    <span>–¶–µ–Ω–∞:</span>
                    <span>ü™ô</span>
                    <span id="modal-total">0</span>
                </div>
                <button class="btn-action" id="modal-action-btn">–ü—Ä–æ–¥–∞—Ç—å –≤—Å—ë</button>
            </div>
        </div>
    </div>

    <!-- Submodal (confirmation) -->
    <div class="submodal" id="submodal">
        <div class="submodal-content">
            <div class="submodal-icon">‚ÑπÔ∏è</div>
            <div class="submodal-title" id="submodal-title">–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ</div>
            <div class="submodal-text" id="submodal-text">–í—ã —É–≤–µ—Ä–µ–Ω—ã?</div>
            <div class="submodal-buttons">
                <button class="btn-ok" id="submodal-ok">OK</button>
                <button class="btn-cancel" onclick="closeSubmodal()">–û—Ç–º–µ–Ω–∞</button>
            </div>
        </div>
    </div>

    <script>
        const isLocal =
            window.location.protocol === 'file:' ||
            window.location.hostname === 'localhost' ||
            window.location.hostname === '127.0.0.1';

        const API_URL = isLocal
            ? 'http://localhost:8000'
            : 'https://happyfarmer2000.bacek97.deno.net';
        const LANG = 'ru';
        let configs = {}, currentTool = 'plant', plots = [];

        const tg = window.Telegram?.WebApp;
        if (tg) { tg.ready(); tg.expand(); }

        async function api(path, options = {}) {
            try {
                const headers = options.headers || {};
                if (tg?.initData) {
                    headers['Authorization'] = tg.initData;
                }
                const res = await fetch(`${API_URL}${path}`, { ...options, headers });
                const text = await res.text();
                try {
                    return JSON.parse(text);
                } catch (e) {
                    console.error('Non-JSON response:', text);
                    return { success: false, error: text.slice(0, 100) || 'Server error' };
                }
            }
            catch (e) {
                console.error('API Error:', e);
                return { success: false, error: e.message };
            }
        }

        function text(obj) { return obj?.[LANG] || obj?.en || ''; }

        // ===== Hasura GraphQL =====
        const HASURA_URL = 'https://happy-farmer-2000.hasura.app/v1/graphql';

        const initData = tg?.initData || '';
        let inventory = {}; // {seed_tomato: 5, item_wheat: 10, silver: 1000}
        let userId = tg?.initDataUnsafe?.user?.id || 0;
        let selectedSeed = null; // Currently selected seed for quick planting

        // ===== GameFSM - State Management with Rollback =====
        class GameFSM {
            constructor() {
                this.history = [];
                this.maxHistory = 10;
                this.pendingActions = this.loadPendingActions();
            }

            // Save current game state for potential rollback
            saveState(plots, inventory) {
                this.history.push({
                    plots: JSON.parse(JSON.stringify(plots)),
                    inventory: JSON.parse(JSON.stringify(inventory)),
                    timestamp: Date.now()
                });
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
            }

            // Rollback to previous state
            rollback() {
                return this.history.pop() || null;
            }

            // Clear state history (after confirmed sync)
            clearHistory() {
                this.history = [];
            }

            // ===== Offline Action Queue =====
            loadPendingActions() {
                try {
                    const stored = localStorage.getItem('farm_pending_actions');
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    console.error('[FSM] Failed to load pending actions:', e);
                    return [];
                }
            }

            savePendingActions() {
                try {
                    localStorage.setItem('farm_pending_actions', JSON.stringify(this.pendingActions));
                } catch (e) {
                    console.error('[FSM] Failed to save pending actions:', e);
                }
            }

            // Add action to pending queue
            queueAction(action) {
                const actionId = `${action.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.pendingActions.push({
                    id: actionId,
                    ...action,
                    createdAt: Date.now(),
                    retries: 0
                });
                this.savePendingActions();
                return actionId;
            }

            // Remove completed action from queue
            completeAction(actionId) {
                this.pendingActions = this.pendingActions.filter(a => a.id !== actionId);
                this.savePendingActions();
            }

            // Get pending action by ID
            getAction(actionId) {
                return this.pendingActions.find(a => a.id === actionId);
            }

            // Process all pending actions (on reconnect)
            async syncPendingActions(executeCallback) {
                if (this.pendingActions.length === 0) return { synced: 0, failed: 0 };

                console.log(`[FSM] Syncing ${this.pendingActions.length} pending actions...`);
                let synced = 0, failed = 0;

                for (const action of [...this.pendingActions]) {
                    try {
                        await executeCallback(action);
                        this.completeAction(action.id);
                        synced++;
                    } catch (e) {
                        console.error(`[FSM] Failed to sync action ${action.id}:`, e);
                        action.retries++;
                        if (action.retries >= 3) {
                            // Give up after 3 retries
                            this.completeAction(action.id);
                            failed++;
                        }
                    }
                }
                this.savePendingActions();
                return { synced, failed };
            }

            hasPendingActions() {
                return this.pendingActions.length > 0;
            }
        }

        const gameFSM = new GameFSM();

        // ===== UI Helper Functions =====
        function showToast(message, type = 'success', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'toastFadeOut 0.3s ease-out forwards';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        function restorePlotVisual(plotId, plotState) {
            const plotEl = document.querySelector(`.plot[data-id="${plotId}"]`);
            if (!plotEl || !plotState) return;

            plotEl.classList.remove('empty', 'harvesting', 'pending', 'error');
            plotEl.classList.add('planted');

            const stageNames = { seed: '1/4', sprout: '2/4', growing: '3/4', ripe: '‚úì' };
            const stage = plotState.stage || 'ripe';
            const img = plotState.config?.stages?.[stage]?.image;
            const html = img
                ? `<img src="${img}" class="crop-img">`
                : `<div class="crop-img" style="font-size:30px;text-align:center">${stage === 'ripe' ? 'üçé' : 'üå±'}</div>`;
            plotEl.innerHTML = `${html}<span class="stage-indicator">${stageNames[stage] || '‚úì'}</span>`;
        }

        // Check online status and sync pending actions
        async function checkAndSyncPendingActions() {
            if (!navigator.onLine || !gameFSM.hasPendingActions()) return;

            const result = await gameFSM.syncPendingActions(async (action) => {
                if (action.type === 'harvest') {
                    const response = await fetch(`${API_URL}/api/harvest?id=${action.objectId}`, {
                        headers: { 'Authorization': tg?.initData || '' }
                    });
                    const result = await response.json();
                    if (result.error && result.error !== 'Withered') {
                        throw new Error(result.error);
                    }
                }
            });

            if (result.synced > 0) {
                showToast(`–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ: ${result.synced} –¥–µ–π—Å—Ç–≤–∏–π`, 'success');
                await loadInventory(); // Refresh inventory from server
            }
            if (result.failed > 0) {
                showToast(`–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: ${result.failed} –¥–µ–π—Å—Ç–≤–∏–π`, 'error');
            }
        }

        // Listen for online event to sync
        window.addEventListener('online', () => {
            console.log('[FSM] Back online, syncing...');
            setTimeout(checkAndSyncPendingActions, 1000);
        });


        async function gql(query, variables = {}) {
            try {
                const res = await fetch(HASURA_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': initData
                    },
                    body: JSON.stringify({ query, variables })
                });
                const json = await res.json();
                if (json.errors) {
                    console.error('GraphQL errors:', json.errors);
                    throw new Error(json.errors[0]?.message || 'GraphQL error');
                }
                return json.data;
            } catch (e) {
                console.error('GQL Error:', e);
                return null;
            }
        }

        // Load user inventory from user_stats
        async function loadInventory() {
            const data = await gql(`
                query {
                    user_stats {
                        key
                        value
                    }
                }
            `);
            inventory = {};
            (data?.user_stats || []).forEach(s => {
                inventory[s.key] = s.value;
            });
            updateResourcesUI();
            return inventory;
        }

        // Update single stat in DB
        async function updateStat(key, value) {
            await gql(`
                mutation($userId: bigint!, $key: String!, $value: Int!) {
                    insert_user_stats_one(
                        object: {user_id: $userId, key: $key, value: $value}
                        on_conflict: {constraint: user_stats_pkey, update_columns: [value, updated_at]}
                    ) { key }
                }
            `, { userId, key, value });
            inventory[key] = value;
        }

        // Add/subtract from stat
        async function modifyStat(key, delta) {
            const current = inventory[key] || 0;
            const newVal = Math.max(0, current + delta);
            await updateStat(key, newVal);
            return newVal;
        }

        function updateResourcesUI() {
            document.getElementById('silver').textContent = (inventory.silver || 0).toLocaleString();
            document.getElementById('gold').textContent = (inventory.gold || 0).toLocaleString();
        }

        // ===== Planted Crops DB =====

        // Save planted crop to DB
        async function savePlantedCrop(plotId, cropCode, stage, plantedAt) {
            console.log('[DB] Saving crop:', { plotId, cropCode, stage, plantedAt });
            const typeCode = `crop_${cropCode}`;
            const plantedAtStr = plantedAt.toString();

            // First create the game object
            const data = await gql(`
                mutation($userId: bigint!, $typeCode: String!, $x: Int!) {
                    insert_game_objects_one(object: {
                        user_id: $userId,
                        type_code: $typeCode,
                        x: $x,
                        y: 0
                    }) {
                        id
                    }
                }
            `, { userId, typeCode, x: plotId });

            console.log('[DB] Created game_object:', data);

            if (data?.insert_game_objects_one?.id) {
                const objectId = data.insert_game_objects_one.id;
                // Save params
                const paramsData = await gql(`
                    mutation($objectId: Int!, $stage: String!, $plantedAt: String!) {
                        insert_game_object_params(objects: [
                            {object_id: $objectId, key: "stage", value: $stage},
                            {object_id: $objectId, key: "planted_at", value: $plantedAt}
                        ]) { affected_rows }
                    }
                `, { objectId, stage, plantedAt: plantedAtStr });
                console.log('[DB] Created params:', paramsData);
                return objectId;
            }
            return null;
        }

        // Load all planted crops from DB
        async function loadPlantedCrops() {
            console.log('[DB] Loading planted crops...');
            const data = await gql(`
                query {
                    game_objects(where: {type_code: {_like: "crop_%"}}) {
                        id
                        type_code
                        x
                        created_at
                        params {
                            key
                            value
                        }
                    }
                }
            `);
            return data?.game_objects || [];
        }

        // Delete planted crop from DB (on harvest)
        async function deletePlantedCrop(plotId) {
            await gql(`
                mutation($plotId: Int!) {
                    delete_game_objects(where: {x: {_eq: $plotId}, type_code: {_like: "crop_%"}}) {
                        affected_rows
                    }
                }
            `, { plotId });
        }

        // Restore planted crops from database on game load
        async function restorePlantedCrops() {
            console.log('[DB] Restoring planted crops...');
            const plantedCrops = await loadPlantedCrops();
            console.log('[DB] Found crops:', plantedCrops);

            for (const obj of plantedCrops) {
                const plotId = obj.x;
                const cropCode = obj.type_code.replace('crop_', '');
                const params = {};
                (obj.params || []).forEach(p => {
                    params[p.key] = p.value;
                });

                const plantedAt = parseInt(params.planted_at) || new Date(obj.created_at).getTime();
                const cropCfg = await api(`/api/configs/crops/${cropCode}`);
                if (!cropCfg) continue;

                // Calculate current stage based on time elapsed
                const elapsed = Date.now() - plantedAt;
                const stageTimes = cropCfg.stage_times || [30000, 60000, 90000]; // default 30s per stage
                const totalGrowTime = stageTimes.reduce((a, b) => a + b * 1000, 0);
                const witherTime = (cropCfg.wither_time || 3600) * 1000; // default 1 hour

                let currentStage = 'seed';
                let isReady = false;
                let isWithered = false;
                let timeSum = 0;
                const stages = ['seed', 'sprout', 'growing', 'ripe'];

                for (let i = 0; i < stageTimes.length; i++) {
                    timeSum += stageTimes[i] * 1000;
                    if (elapsed >= timeSum && i < stages.length - 1) {
                        currentStage = stages[i + 1];
                    }
                }

                if (elapsed >= totalGrowTime) {
                    currentStage = 'ripe';
                    isReady = true;

                    // Check if crop has withered (past wither deadline)
                    if (elapsed >= totalGrowTime + witherTime) {
                        currentStage = 'withered';
                        isReady = false;
                        isWithered = true;
                    }
                }

                // Update plot state
                // Extract yield amount from params for optimistic harvest display
                const yieldFromParams = params.yield ? parseInt(params.yield) : null;
                const yieldFromConfig = cropCfg.products?.[0]?.yield?.[0] || 2;
                const yieldAmount = yieldFromParams || yieldFromConfig;

                console.log(`[DB] Plot ${plotId}: crop=${cropCode}, stage=${currentStage}, isWithered=${isWithered}, yieldFromParams=${yieldFromParams}, yieldFromConfig=${yieldFromConfig}, final=${yieldAmount}, params=`, params);

                plots[plotId] = {
                    state: isWithered ? 'withered' : (isReady ? 'ready' : 'planted'),
                    crop: cropCode,
                    stage: currentStage,
                    config: cropCfg,
                    plantedAt,
                    objectId: obj.id,  // Important for harvest
                    yieldAmount  // Preloaded for instant harvest feedback
                };

                // Update plot visual
                const plotEl = document.querySelector(`.plot[data-id="${plotId}"]`);
                if (plotEl) {
                    plotEl.classList.remove('empty', 'blocked');
                    plotEl.classList.add('planted');

                    const stageNames = { seed: '1/4', sprout: '2/4', growing: '3/4', ripe: '‚úì', withered: 'üíÄ' };
                    const img = cropCfg?.stages?.[currentStage]?.image;
                    const html = img
                        ? `<img src="${img}" class="crop-img">`
                        : `<div class="crop-img" style="font-size:30px;text-align:center">${isWithered ? 'ü•Ä' : (currentStage === 'ripe' ? 'üçé' : 'üå±')}</div>`;
                    plotEl.innerHTML = `${html}<span class="stage-indicator">${stageNames[currentStage]}</span>`;

                    // Add withered styling
                    if (isWithered) {
                        plotEl.style.filter = 'grayscale(60%) brightness(0.8)';
                    }
                }
            }

            // Start countdown timer updates
            startCountdownTimers();
        }

        // ===== Countdown Timer System =====
        let countdownInterval = null;

        function formatTime(seconds) {
            if (seconds <= 0) return '0s';
            if (seconds < 60) return `${Math.floor(seconds)}s`;
            if (seconds < 3600) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
            }
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        }

        function updatePlotTimer(plotId) {
            const plot = plots[plotId];
            const plotEl = document.querySelector(`.plot[data-id="${plotId}"]`);
            if (!plotEl || !plot || plot.state === 'empty' || plot.state === 'blocked') return;

            // Remove existing timer
            const existingTimer = plotEl.querySelector('.countdown-timer');
            if (existingTimer) existingTimer.remove();

            if (plot.state === 'withered') return; // No timer for withered

            const cropCfg = plot.config;
            if (!cropCfg) return;

            const stageTimes = cropCfg.stage_times || [30, 60, 90]; // in seconds
            const witherTime = cropCfg.wither_time || 3600;
            const elapsed = (Date.now() - plot.plantedAt) / 1000; // in seconds

            let timeSum = 0;
            let nextStageTime = null;
            let isLastStage = false;

            // Find time to next stage
            for (let i = 0; i < stageTimes.length; i++) {
                timeSum += stageTimes[i];
                if (elapsed < timeSum) {
                    nextStageTime = timeSum - elapsed;
                    break;
                }
            }

            // If past all stages, show wither countdown
            const totalGrowTime = stageTimes.reduce((a, b) => a + b, 0);
            if (elapsed >= totalGrowTime) {
                isLastStage = true;
                const witherDeadline = totalGrowTime + witherTime;
                nextStageTime = witherDeadline - elapsed;
            }

            if (nextStageTime === null || nextStageTime <= 0) return;

            // Determine urgency class
            let urgencyClass = '';
            if (isLastStage) {
                // Wither countdown - more urgent
                if (nextStageTime < 60) urgencyClass = 'danger';
                else if (nextStageTime < 300) urgencyClass = 'warning';
            } else {
                // Growth countdown - less urgent
                if (nextStageTime < 10) urgencyClass = 'warning';
            }

            const icon = isLastStage ? '‚è∞' : 'üå±';
            const timer = document.createElement('div');
            timer.className = `countdown-timer ${urgencyClass}`;
            timer.innerHTML = `${icon} ${formatTime(nextStageTime)}`;
            plotEl.appendChild(timer);
        }

        function updateAllPlotTimers() {
            for (let i = 0; i < plots.length; i++) {
                if (plots[i] && plots[i].state !== 'empty' && plots[i].state !== 'blocked') {
                    updatePlotTimer(i);

                    // Check for stage transitions
                    checkStageTransition(i);
                }
            }
        }

        function checkStageTransition(plotId) {
            const plot = plots[plotId];
            if (!plot || !plot.config || plot.state === 'empty' || plot.state === 'withered') return;

            const cropCfg = plot.config;
            const stageTimes = cropCfg.stage_times || [30, 60, 90];
            const witherTime = cropCfg.wither_time || 3600;
            const elapsed = (Date.now() - plot.plantedAt) / 1000;
            const totalGrowTime = stageTimes.reduce((a, b) => a + b, 0);

            // Dynamic stages: read from config, filter out 'withered', ensure proper order
            const allStageKeys = Object.keys(cropCfg.stages || {});
            // Build stages array: start with 'seed', then intermediate stages, end with 'ripe'
            const stages = allStageKeys.filter(s => s !== 'withered' && s !== 'seed' && s !== 'ripe');
            stages.unshift('seed'); // Add seed at the beginning
            stages.push('ripe');    // Add ripe at the end

            let timeSum = 0;
            let currentStageIndex = 0;

            // Determine current stage based on elapsed time
            for (let i = 0; i < stageTimes.length; i++) {
                timeSum += stageTimes[i];
                if (elapsed >= timeSum && i + 1 < stages.length) {
                    currentStageIndex = i + 1;
                }
            }

            let currentStage = stages[currentStageIndex] || 'seed';

            if (elapsed >= totalGrowTime) {
                currentStage = 'ripe';
                plot.state = 'ready';
            }

            // Check for wither (only if wither_time > 0)
            if (witherTime > 0 && elapsed >= totalGrowTime + witherTime) {
                currentStage = 'withered';
                plot.state = 'withered';
            }

            // Update visual if stage changed
            if (currentStage !== plot.stage) {
                plot.stage = currentStage;
                const plotEl = document.querySelector(`.plot[data-id="${plotId}"]`);
                if (plotEl) {
                    // Dynamic stage indicator: X/N format
                    const stageIndex = stages.indexOf(currentStage);
                    const totalStages = stages.length;
                    const isRipe = currentStage === 'ripe';
                    const isWithered = currentStage === 'withered';
                    const stageLabel = isWithered ? 'üíÄ' : (isRipe ? '‚úì' : `${stageIndex + 1}/${totalStages}`);

                    const img = cropCfg?.stages?.[currentStage]?.image;
                    const html = img
                        ? `<img src="${img}" class="crop-img">`
                        : `<div class="crop-img" style="font-size:30px;text-align:center">${isWithered ? 'ü•Ä' : (isRipe ? 'üçé' : 'üå±')}</div>`;
                    plotEl.innerHTML = `${html}<span class="stage-indicator">${stageLabel}</span>`;

                    if (isWithered) {
                        plotEl.style.filter = 'grayscale(60%) brightness(0.8)';
                    }
                }
            }
        }

        function startCountdownTimers() {
            // Clear existing interval
            if (countdownInterval) clearInterval(countdownInterval);

            // Update immediately
            updateAllPlotTimers();

            // Update every second
            countdownInterval = setInterval(updateAllPlotTimers, 1000);
        }

        // Map panning functionality
        let isPanning = false, startX = 0, startY = 0, panX = 0, panY = 0;

        function initMapPanning() {
            const gameWorld = document.getElementById('game-world');

            // Mouse events (desktop)
            gameWorld.addEventListener('mousedown', (e) => {
                if (e.target.closest('.map-object, .plot, .tool, .action-btn')) return;
                isPanning = true;
                startX = e.clientX - panX;
                startY = e.clientY - panY;
                gameWorld.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                panX = e.clientX - startX;
                panY = e.clientY - startY;
                updatePan();
            });

            document.addEventListener('mouseup', () => {
                isPanning = false;
                document.getElementById('game-world').style.cursor = 'grab';
            });

            // Touch events (mobile)
            gameWorld.addEventListener('touchstart', (e) => {
                if (e.target.closest('.map-object, .plot, .tool, .action-btn')) return;
                if (e.touches.length === 1) {
                    isPanning = true;
                    startX = e.touches[0].clientX - panX;
                    startY = e.touches[0].clientY - panY;
                }
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!isPanning || e.touches.length !== 1) return;
                panX = e.touches[0].clientX - startX;
                panY = e.touches[0].clientY - startY;
                updatePan();
            }, { passive: true });

            document.addEventListener('touchend', () => { isPanning = false; });

            gameWorld.style.cursor = 'grab';
        }

        function updatePan() {
            const gameWorld = document.getElementById('game-world');
            gameWorld.style.transform = `translate(${panX}px, ${panY}px)`;
        }

        async function init() {
            const user = tg?.initDataUnsafe?.user;
            // Update level circle
            const levelCircle = document.getElementById('level-circle');
            if (levelCircle) levelCircle.textContent = '5';

            configs = await api('/api/configs');
            const plotCfg = await api('/api/configs/plots/plot');

            // Load crops config for quick seed selection
            CONFIGS.crops = await api('/api/configs/crops');

            // Cache plot config for optimistic harvest
            CONFIGS.plots = { plot: plotCfg };

            // Load user inventory from database
            await loadInventory();

            // Sync any pending offline actions
            await checkAndSyncPendingActions();

            // Load map objects (factories) FIRST so they appear behind plots
            await loadMapObjects();

            // Load animals from API and display them
            await loadAnimals();

            // Load plots count from API
            const plotsData = await api('/api/plots');
            const plotsCount = plotsData?.plots_count || plotCfg?.base_plots || 6;
            const totalPlots = plotCfg?.total_plots || 32;
            const grid = document.getElementById('farm-grid');
            const emptyPlotImg = plotCfg?.stages?.empty?.image;
            const blockedPlotImg = plotCfg?.stages?.blocked?.image;
            const cols = 4;
            const gapX = 52, gapY = 26; // half tile size for isometric grid

            for (let i = 0; i < totalPlots; i++) {
                const isBlocked = i >= plotsCount;
                plots[i] = { state: isBlocked ? 'blocked' : 'empty', crop: null, stage: 0 };
                const row = Math.floor(i / cols);
                const col = i % cols;

                // Isometric diamond grid positioning (row 0 at top-left)
                const x = (row - col) * gapX + 200;
                const y = (col + row) * gapY + 50;

                const plot = document.createElement('div');
                plot.className = isBlocked ? 'plot blocked' : 'plot empty';
                plot.dataset.id = i;
                plot.style.left = `${x}px`;
                plot.style.top = `${y}px`;

                const plotImg = isBlocked ? blockedPlotImg : emptyPlotImg;
                if (plotImg) {
                    plot.style.backgroundImage = `url('${plotImg}')`;
                }
                if (isBlocked) {
                    plot.style.opacity = '0.5';
                }
                plot.onclick = () => onPlotClick(i);
                grid.appendChild(plot);
            }

            // Load planted crops from database and restore visuals
            await restorePlantedCrops();

            // Setup toolbar
            document.querySelectorAll('.tool').forEach(tool => {
                tool.onclick = () => {
                    document.querySelector('.tool.active')?.classList.remove('active');
                    tool.classList.add('active');
                    currentTool = tool.dataset.tool;
                };
            });

            // Enable map panning
            initMapPanning();
        }

        async function loadMapObjects() {
            const factoriesLayer = document.getElementById('factories-layer');
            const factories = await api('/api/configs/factories');

            for (const [code, cfg] of Object.entries(factories || {})) {
                if (!cfg.position) continue; // Skip factories without position

                const isDecoration = cfg.decoration === true;
                const obj = document.createElement('div');
                obj.className = isDecoration ? 'map-object decoration' : 'map-object';
                // Position from center using translate for proper background attachment
                obj.style.left = '50%';
                obj.style.top = '50%';
                obj.style.transform = `translate(${cfg.position.x}%, ${cfg.position.y}%)`;
                if (isDecoration) {
                    obj.style.pointerEvents = 'none';
                    obj.style.cursor = 'default';
                }

                // Get image from stages (default to idle)
                const stageImage = cfg.stages?.idle?.image || cfg.stages?.ready?.image;
                const imagePath = stageImage ? `${stageImage}` : null;

                const iconWidth = cfg.size?.width || 80;
                const iconHtml = imagePath
                    ? `<img src="${imagePath}" alt="${text(cfg.name)}" style="width:${iconWidth}px;height:auto;">`
                    : `<span style="font-size:70px">${cfg.icon || 'üè≠'}</span>`;

                // Decorations don't have labels
                obj.innerHTML = isDecoration
                    ? `<div class="object-icon">${iconHtml}</div>`
                    : `<div class="object-icon">${iconHtml}</div><div class="object-label">${text(cfg.name)}</div>`;

                if (!isDecoration) {
                    obj.onclick = () => showFactoryModal(code, cfg);
                }
                factoriesLayer.appendChild(obj);
            }
        }

        // ===== Animals Display =====
        async function loadAnimals() {
            const animalsLayer = document.getElementById('animals-layer');
            if (!animalsLayer) return;
            animalsLayer.innerHTML = '';

            // Fetch owned animals from API
            const ownedAnimals = await api('/api/animals');
            const animalsConfig = await api('/api/configs/animals');

            if (!ownedAnimals || !animalsConfig) {
                console.log('[ANIMALS] No animals found or config missing');
                return;
            }

            ownedAnimals.forEach(animal => {
                const code = animal.type_code.replace('animal_', '');
                const cfg = animalsConfig[code];
                if (!cfg) return;

                const params = {};
                (animal.params || []).forEach(p => params[p.key] = p.value);
                const stage = params.stage || 'hungry';

                const animalEl = document.createElement('div');
                animalEl.className = 'animal-object';
                animalEl.dataset.id = animal.id;
                animalEl.style.left = '50%';
                animalEl.style.top = '50%';
                animalEl.style.transform = `translate(${animal.x}px, ${animal.y}px)`;

                const stageImg = cfg.stages?.[stage]?.image || cfg.icon;
                const iconHtml = stageImg.startsWith('fsm/') || stageImg.startsWith('/')
                    ? `<img src="${stageImg}" style="width:80px;height:auto;">`
                    : `<span style="font-size:60px">${stageImg}</span>`;

                const statusIcon = stage === 'ready' ? 'ü•õ' : stage === 'fed' ? '‚è≥' : 'üòã';

                animalEl.innerHTML = `
                    <div class="animal-icon">${iconHtml}</div>
                    <div class="animal-label">${text(cfg.name)}</div>
                    <div class="animal-status">${statusIcon}</div>
                `;

                animalEl.onclick = () => showAnimalModal(animal.id, code, cfg, params);
                animalsLayer.appendChild(animalEl);
            });
        }

        // Show modal for animal details
        async function showAnimalModal(id, code, cfg, params) {
            document.getElementById('modal-title').textContent = text(cfg.name);
            document.getElementById('modal-footer').style.display = 'none';

            const stage = params.stage || 'hungry';
            const stageImg = cfg.stages?.[stage]?.image || cfg.icon;

            let html = `<div style="text-align:center; padding:20px;">`;
            if (stageImg.startsWith('fsm/') || stageImg.startsWith('/')) {
                html += `<img src="${stageImg}" style="width:150px;height:auto;margin-bottom:15px;border-radius:12px;">`;
            } else {
                html += `<div style="font-size:80px;margin-bottom:15px;">${stageImg}</div>`;
            }

            html += `
                <p style="color:#5D4037;margin-bottom:15px;">${text(cfg.description)}</p>
                <div style="background:rgba(255,255,255,0.5);padding:15px;border-radius:10px;margin-bottom:15px;text-align:left;">
                    <div><b>–°—Ç–∞—Ç—É—Å:</b> ${text(cfg.stages?.[stage]?.messages) || stage}</div>
                    ${stage === 'fed' ? `<div><b>–ì–æ—Ç–æ–≤ —á–µ—Ä–µ–∑:</b> ${Math.max(0, Math.floor((params.ready_at - Date.now() / 1000) / 60))} –º–∏–Ω</div>` : ''}
                </div>
            `;

            if (stage === 'hungry') {
                html += `<button onclick="feedAnimal(${id})" style="width:100%;padding:12px;background:#4CAF50;color:white;border:none;border-radius:8px;font-weight:bold;cursor:pointer;">üçñ –ü–æ–∫–æ—Ä–º–∏—Ç—å</button>`;
            } else if (stage === 'ready') {
                html += `<button onclick="collectAnimalProduct(${id})" style="width:100%;padding:12px;background:#FF9800;color:white;border:none;border-radius:8px;font-weight:bold;cursor:pointer;">ü•õ –°–æ–±—Ä–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ü–∏—é</button>`;
            } else {
                html += `<button disabled style="width:100%;padding:12px;background:#ccc;color:#666;border:none;border-radius:8px;font-weight:bold;">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ...</button>`;
            }

            html += `</div>`;
            document.getElementById('modal-body').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }

        async function feedAnimal(id) {
            const res = await api('/api/feed_animal', { method: 'POST', body: JSON.stringify({ id }) });
            if (res.success) {
                showToast('–ñ–∏–≤–æ—Ç–Ω–æ–µ –ø–æ–∫–æ—Ä–º–ª–µ–Ω–æ!', 'success');
                closeModal();
                loadAnimals();
            } else {
                showToast(res.error || '–û—à–∏–±–∫–∞ –∫–æ—Ä–º–ª–µ–Ω–∏—è', 'error');
            }
        }

        async function collectAnimalProduct(id) {
            const res = await api('/api/collect_animal', { method: 'POST', body: JSON.stringify({ id }) });
            if (res.success) {
                showToast(`–°–æ–±—Ä–∞–Ω–æ: ${res.product} x${res.count}`, 'success');
                closeModal();
                loadInventory();
                loadAnimals();
            } else {
                showToast(res.error || '–û—à–∏–±–∫–∞ —Å–±–æ—Ä–∞', 'error');
            }
        }

        async function buyAnimal(code) {
            const res = await api('/api/buy_animal', { method: 'POST', body: JSON.stringify({ code }) });
            if (res.success) {
                showToast('–ñ–∏–≤–æ—Ç–Ω–æ–µ –∫—É–ø–ª–µ–Ω–æ!', 'success');
                closeModal();
                loadInventory();
                loadAnimals();
            } else {
                showToast(res.error || '–û—à–∏–±–∫–∞ –ø–æ–∫—É–ø–∫–∏', 'error');
            }
        }

        window.feedAnimal = feedAnimal;
        window.collectAnimalProduct = collectAnimalProduct;
        window.buyAnimal = buyAnimal;

        async function showFactoryModal(code, cfg) {
            document.getElementById('modal-title').textContent = text(cfg.name);
            const crops = await api('/api/configs/crops');
            const animals = await api('/api/configs/animals');
            const factories = await api('/api/configs/factories');

            // Build item name lookup from crops, animal products, AND factory products
            const itemNames = {};
            // Add crops
            for (const [cropCode, cropCfg] of Object.entries(crops || {})) {
                itemNames[cropCode] = cropCfg.name;
            }
            // Add animal products
            for (const [animalCode, animalCfg] of Object.entries(animals || {})) {
                for (const product of animalCfg.products || []) {
                    if (product.code && product.name) {
                        itemNames[product.code] = product.name;
                    }
                }
            }
            // Add factory products
            for (const [factoryCode, factoryCfg] of Object.entries(factories || {})) {
                const fullCfg = await api(`/api/configs/factories/${factoryCode}`);
                for (const product of fullCfg?.products || []) {
                    if (product.code && product.name) {
                        itemNames[product.code] = product.name;
                    }
                }
            }

            let html = `<p style="margin-bottom:15px;color:#5D4037">${text(cfg.description)}</p>`;
            html += '<div class="shop-grid">';

            for (const recipe of cfg.recipes || []) {
                // Check ingredients
                let ingredientsHtml = '';
                let canProduce = true;

                for (const input of recipe.inputs || []) {
                    const itemKey = `item_${input.item}`;
                    const have = inventory[itemKey] || 0;
                    const need = input.count;
                    const enough = have >= need;
                    if (!enough) canProduce = false;

                    const itemName = text(itemNames[input.item]) || input.item;
                    const color = enough ? '#4CAF50' : '#F44336';
                    ingredientsHtml += `<div style="font-size:11px;color:${color}">${itemName}: ${have}/${need}</div>`;
                }

                const btnStyle = canProduce
                    ? 'background:#4CAF50;color:white;cursor:pointer'
                    : 'background:#ccc;color:#666;cursor:not-allowed';
                const onclick = canProduce
                    ? `startProduction('${code}','${recipe.code}')`
                    : '';

                // Get product icon
                const product = recipe.products?.[0];
                const productIcon = product?.code?.includes('juice') ? 'üßÉ' : product?.code?.includes('chips') ? 'üçü' : 'üì¶';

                html += `<div class="shop-item" ${onclick ? `onclick="${onclick}"` : ''}>
                    <div class="shop-item-icon">${productIcon}</div>
                    <div class="shop-item-name">${text(recipe.name)}</div>
                    <div style="font-size:10px;color:#888">‚è± ${Math.floor(recipe.time / 60)}–º–∏–Ω</div>
                    <div style="margin-top:5px;border-top:1px solid #eee;padding-top:5px">
                        ${ingredientsHtml}
                    </div>
                    <div style="margin-top:5px;padding:3px 6px;border-radius:4px;${btnStyle}">
                        ${canProduce ? '‚ñ∂ –ü—Ä–æ–∏–∑–≤–µ—Å—Ç–∏' : '‚úó –ù–µ—Ç –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤'}
                    </div>
                </div>`;
            }
            html += '</div>';
            document.getElementById('modal-body').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }

        // Store current factory configs for startProduction
        let factoryConfigs = {};

        async function startProduction(factoryCode, recipeCode) {
            // Get factory config
            const cfg = await api(`/api/configs/factories/${factoryCode}`);
            const recipe = cfg?.recipes?.find(r => r.code === recipeCode);
            if (!recipe) {
                alert('–†–µ—Ü–µ–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!');
                return;
            }

            // Check and deduct ingredients
            for (const input of recipe.inputs || []) {
                const itemKey = `item_${input.item}`;
                const have = inventory[itemKey] || 0;
                if (have < input.count) {
                    alert(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ ${input.item}!`);
                    return;
                }
            }

            // Deduct ingredients
            for (const input of recipe.inputs || []) {
                await modifyStat(`item_${input.item}`, -input.count);
            }

            closeModal();

            // Add products after production time (simplified - instant for demo)
            for (const product of recipe.products || []) {
                await modifyStat(`item_${product.code}`, product.count);
            }

            // Add experience
            await modifyStat('exp', recipe.exp || 10);

            alert(`${text(recipe.name)} –≥–æ—Ç–æ–≤!`);
        }

        window.startProduction = startProduction;

        async function onPlotClick(id) {
            const plot = plots[id];
            console.log('[PLOT] Click on plot', id, 'state:', plot?.state, 'currentTool:', currentTool);

            // Ready crop - always harvest on click
            if (plot.state === 'ready') {
                await harvestCrop(id);
                return;
            }

            // Withered crop - clear it
            if (plot.state === 'withered') {
                await clearWitheredCrop(id);
                return;
            }

            // Growing crop - show stages modal
            if (plot.state === 'planted' && plot.config) {
                showCropGrowthModal(id, plot);
                return;
            }

            // Empty plot - plant selected seed or show selector
            if (plot.state === 'empty') {
                if (selectedSeed && (inventory[`seed_${selectedSeed}`] || 0) > 0) {
                    // Plant selected seed directly
                    await plantCrop(id, selectedSeed);
                } else {
                    // No seed selected or out of seeds - show selector
                    await showCropSelector(id);
                }
            }

            // Blocked plot - buy it
            if (plot.state === 'blocked') {
                await showBuyPlotModal(id);
            }
        }

        async function showBuyPlotModal(id) {
            const plotCfg = CONFIGS.plots?.plot;
            const plotsData = await api('/api/plots');
            const currentPlots = plotsData?.plots_count || 6;
            const basePlots = plotsData?.base_plots || 6;
            const plotPrice = plotCfg?.plot_price || 100;
            const priceMultiplier = plotCfg?.price_multiplier || 1.5;

            const extraPlots = currentPlots - basePlots;
            const price = Math.floor(plotPrice * Math.pow(priceMultiplier, extraPlots));

            const submodal = document.getElementById('submodal');
            const title = document.getElementById('submodal-title');
            const text = document.getElementById('submodal-text');
            const okBtn = document.getElementById('submodal-ok');

            title.textContent = '–ö—É–ø–∏—Ç—å –≥—Ä—è–¥–∫—É';
            text.textContent = `–í—ã —Ö–æ—Ç–∏—Ç–µ –∫—É–ø–∏—Ç—å –Ω–æ–≤—É—é –≥—Ä—è–¥–∫—É –∑–∞ ${price} ü™ô?`;

            okBtn.onclick = async () => {
                closeSubmodal();
                await buyPlot();
            };

            submodal.classList.add('active');
        }

        async function buyPlot() {
            const response = await fetch(`${API_URL}/api/buy_plot`, {
                method: 'POST',
                headers: { 'Authorization': tg?.initData || '' }
            });
            const result = await response.json();

            if (result.success) {
                showToast('–ì—Ä—è–¥–∫–∞ –∫—É–ø–ª–µ–Ω–∞!', 'success');
                // Refresh the whole game state or just the plots
                location.reload();
            } else {
                showToast(result.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ', 'error');
            }
        }

        function closeSubmodal() {
            document.getElementById('submodal').classList.remove('active');
        }

        // Show modal with crop growth stages information
        function showCropGrowthModal(plotId, plot) {
            const cropCfg = plot.config;
            const stageTimes = cropCfg.stage_times || [];
            const elapsed = (Date.now() - plot.plantedAt) / 1000;
            const totalGrowTime = stageTimes.reduce((a, b) => a + b, 0);
            const witherTime = cropCfg.wither_time || 0;

            // Get dynamic stages from config
            const allStageKeys = Object.keys(cropCfg.stages || {});
            const intermediateStages = allStageKeys.filter(s => s !== 'withered' && s !== 'seed' && s !== 'ripe');
            const stages = allStageKeys.includes('seed') ? ['seed', ...intermediateStages, 'ripe'] : [...intermediateStages, 'ripe'];

            // Calculate current stage
            let timeSum = 0;
            let currentStageIndex = 0;
            for (let i = 0; i < stageTimes.length; i++) {
                timeSum += stageTimes[i];
                if (elapsed >= timeSum && i + 1 < stages.length) {
                    currentStageIndex = i + 1;
                }
            }
            if (elapsed >= totalGrowTime) {
                currentStageIndex = stages.length - 1;
            }

            document.getElementById('modal-title').textContent = text(cropCfg.name);
            document.getElementById('modal-footer').style.display = 'none';

            let html = `<div style="padding: 15px;">`;

            // Current crop image
            const currentStage = stages[currentStageIndex];
            const currentImg = cropCfg.stages?.[currentStage]?.image;
            if (currentImg) {
                html += `<div style="text-align:center;margin-bottom:15px;">
                    <img src="${currentImg}" style="width:120px;height:auto;">
                </div>`;
            }

            // Description
            html += `<p style="color:#5D4037;margin-bottom:15px;text-align:center;">${text(cropCfg.description)}</p>`;

            // Progress bar
            const progress = Math.min(100, (elapsed / totalGrowTime) * 100);
            html += `<div style="background:#ddd;border-radius:10px;height:20px;margin-bottom:20px;overflow:hidden;">
                <div style="background:linear-gradient(90deg, #4CAF50, #8BC34A);height:100%;width:${progress}%;transition:width 0.3s;display:flex;align-items:center;justify-content:center;color:white;font-size:11px;font-weight:bold;">
                    ${Math.floor(progress)}%
                </div>
            </div>`;

            // Stages timeline
            html += `<div style="font-weight:bold;margin-bottom:10px;color:#333;">üìä –°—Ç–∞–¥–∏–∏ —Ä–æ—Å—Ç–∞:</div>`;
            html += `<div style="display:flex;flex-direction:column;gap:8px;">`;

            let accumulatedTime = 0;
            for (let i = 0; i < stages.length; i++) {
                const stage = stages[i];
                const stageTime = stageTimes[i] || 0;
                const stageInfo = cropCfg.stages?.[stage];
                const stageName = stageInfo?.messages ? text(stageInfo.messages) : stage;
                const stageImg = stageInfo?.image;

                const isCurrent = i === currentStageIndex;
                const isPast = i < currentStageIndex;
                const isFuture = i > currentStageIndex;

                // Calculate time info
                let timeInfo = '';
                if (i === 0) {
                    timeInfo = '0:00';
                } else if (i < stageTimes.length) {
                    accumulatedTime += stageTimes[i - 1] || 0;
                    timeInfo = formatTime(stageTime);
                } else {
                    // Ripe stage
                    timeInfo = '‚úì –£—Ä–æ–∂–∞–π';
                }

                // Time remaining for current stage
                let timeRemaining = '';
                if (isCurrent && i < stageTimes.length) {
                    let prevTime = 0;
                    for (let j = 0; j < i; j++) prevTime += stageTimes[j] || 0;
                    const stageEnd = prevTime + (stageTimes[i] || 0);
                    const remaining = stageEnd - elapsed;
                    if (remaining > 0) {
                        timeRemaining = `<span style="color:#FF9800;font-size:11px;margin-left:5px;">‚è± ${formatTime(remaining)}</span>`;
                    }
                }

                const bgColor = isCurrent ? 'rgba(76, 175, 80, 0.2)' : (isPast ? 'rgba(200, 200, 200, 0.3)' : 'rgba(255, 255, 255, 0.5)');
                const borderColor = isCurrent ? '#4CAF50' : (isPast ? '#9E9E9E' : '#E0E0E0');
                const textColor = isPast ? '#9E9E9E' : '#333';
                const icon = isPast ? '‚úÖ' : (isCurrent ? 'üå±' : '‚è≥');

                html += `<div style="display:flex;align-items:center;gap:10px;padding:8px 12px;background:${bgColor};border:2px solid ${borderColor};border-radius:8px;">
                    <span style="font-size:16px;">${icon}</span>
                    ${stageImg ? `<img src="${stageImg}" style="width:35px;height:35px;object-fit:contain;border-radius:4px;">` : ''}
                    <div style="flex:1;">
                        <div style="font-weight:bold;color:${textColor};">${stageName}${timeRemaining}</div>
                        <div style="font-size:11px;color:#888;">${i === stages.length - 1 ? '–ì–æ—Ç–æ–≤–æ –∫ —Å–±–æ—Ä—É' : `–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${timeInfo}`}</div>
                    </div>
                    <span style="font-size:12px;color:#666;">${i + 1}/${stages.length}</span>
                </div>`;
            }
            html += `</div>`;

            // Wither warning
            if (witherTime > 0) {
                html += `<div style="margin-top:15px;padding:10px;background:rgba(255, 152, 0, 0.1);border:1px solid #FF9800;border-radius:8px;font-size:12px;color:#E65100;">
                    ‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ: —É—Ä–æ–∂–∞–π —É–≤—è–Ω–µ—Ç —á–µ—Ä–µ–∑ <b>${formatTime(witherTime)}</b> –ø–æ—Å–ª–µ —Å–æ–∑—Ä–µ–≤–∞–Ω–∏—è!
                </div>`;
            } else {
                html += `<div style="margin-top:15px;padding:10px;background:rgba(76, 175, 80, 0.1);border:1px solid #4CAF50;border-radius:8px;font-size:12px;color:#2E7D32;">
                    ‚úÖ –≠—Ç–æ —Ä–∞—Å—Ç–µ–Ω–∏–µ –Ω–µ —É–≤—è–¥–∞–µ—Ç ‚Äî –º–æ–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è!
                </div>`;
            }

            // Stats
            html += `<div style="margin-top:15px;display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:12px;">
                <div style="padding:8px;background:rgba(255,255,255,0.5);border-radius:6px;">üí∞ –ü—Ä–æ–¥–∞–∂–∞: ${cropCfg.products?.[0]?.sell_silver || 0} ü™ô</div>
                <div style="padding:8px;background:rgba(255,255,255,0.5);border-radius:6px;">‚≠ê –û–ø—ã—Ç: ${cropCfg.exp || 0}</div>
                <div style="padding:8px;background:rgba(255,255,255,0.5);border-radius:6px;">üì¶ –£—Ä–æ–∂–∞–π: ${cropCfg.products?.[0]?.yield?.join('-') || '?'} —à—Ç</div>
                <div style="padding:8px;background:rgba(255,255,255,0.5);border-radius:6px;">‚è∞ –û–±—â–µ–µ –≤—Ä–µ–º—è: ${formatTime(totalGrowTime)}</div>
            </div>`;

            html += `</div>`;

            document.getElementById('modal-body').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }


        // Clear a withered crop from the plot
        async function clearWitheredCrop(plotId) {
            const plot = plots[plotId];
            const plotEl = document.querySelector(`.plot[data-id="${plotId}"]`);
            if (!plotEl) return;

            const emptyPlotImg = CONFIGS.plots?.plot?.stages?.empty?.image;

            // Save previous state for rollback
            const prevPlotState = JSON.parse(JSON.stringify(plot));
            const prevHtml = plotEl.innerHTML;
            const prevFilter = plotEl.style.filter;

            // Show clearing animation (optimistic)
            plotEl.innerHTML = `<div class="harvest-popup" style="background: linear-gradient(135deg, rgba(139, 69, 19, 0.95), rgba(101, 67, 33, 0.95));">üóëÔ∏è –£–±—Ä–∞–Ω–æ</div>`;
            plotEl.style.filter = '';

            // Try to delete from server (if objectId exists)
            let success = true;
            let errorMessage = '';

            if (plot?.objectId) {
                try {
                    const response = await fetch(`${API_URL}/api/harvest?id=${plot.objectId}`, {
                        headers: { 'Authorization': tg?.initData || '' }
                    });
                    const result = await response.json();

                    // Check for errors (Withered is OK - expected response)
                    if (result.error && result.error !== 'Withered') {
                        success = false;
                        errorMessage = result.error;
                    }
                } catch (e) {
                    console.log('[CLEAR] Error deleting withered crop:', e);
                    success = false;
                    errorMessage = e.message || '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏';
                }
            }

            if (success) {
                // Clear plot visually
                setTimeout(() => {
                    plotEl.innerHTML = '';
                    plotEl.classList.remove('planted');
                    plotEl.classList.add('empty');
                    plotEl.style.filter = '';
                    if (emptyPlotImg) {
                        plotEl.style.backgroundImage = `url('${emptyPlotImg}')`;
                    }
                    plots[plotId] = { state: 'empty', crop: null, stage: 0, objectId: null };
                }, 800);

                showToast('–£–≤—è–¥—à–∏–π —É—Ä–æ–∂–∞–π —É–±—Ä–∞–Ω', 'success');
            } else {
                // Rollback on error
                plotEl.classList.add('error');
                setTimeout(() => {
                    plotEl.innerHTML = prevHtml;
                    plotEl.style.filter = prevFilter;
                    plotEl.classList.remove('error');
                    plots[plotId] = prevPlotState;
                }, 500);

                showToast(`–û—à–∏–±–∫–∞: ${errorMessage}`, 'error');
            }
        }

        // Open seed selector modal to choose which seed to use for quick planting
        async function openSeedSelector() {
            const crops = await api('/api/configs/crops');
            document.getElementById('modal-title').textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ–º–µ–Ω–∞';
            document.getElementById('modal-footer').style.display = 'none';

            let html = '<div class="shop-grid">';
            for (const [code, c] of Object.entries(crops || {})) {
                const seedCount = inventory[`seed_${code}`] || 0;
                const seedImg = c.stages?.seed?.image;
                const iconHtml = seedImg ? `<img src="${seedImg}" style="width:40px;height:40px">` : 'üå±';
                const isSelected = selectedSeed === code;
                const style = isSelected ? 'border: 2px solid #4CAF50; background: rgba(76,175,80,0.2);' : '';

                html += `<div class="shop-item" style="${style}" onclick="selectSeed('${code}')">
                    ${seedCount > 0 ? `<span class="shop-item-qty">${seedCount}</span>` : ''}
                    <div class="shop-item-icon">${iconHtml}</div>
                    <div class="shop-item-name">${text(c.name)}</div>
                    <div class="shop-item-price">${seedCount} —à—Ç</div>
                </div>`;
            }
            html += '</div>';

            document.getElementById('modal-body').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }

        // Select a seed for quick planting
        function selectSeed(cropCode) {
            selectedSeed = cropCode;
            const crops = CONFIGS?.crops || {};
            const crop = crops[cropCode];

            // Update toolbar button
            const seedIcon = document.getElementById('selected-seed-icon');
            const seedName = document.getElementById('selected-seed-name');
            if (crop) {
                const img = crop.stages?.seed?.image;
                seedIcon.innerHTML = img ? `<img src="${img}" style="width:28px;height:28px">` : 'üå±';
                seedName.textContent = text(crop.name);
            }

            closeModal();
        }

        let CONFIGS = {}; // Will be populated on init

        async function showCropSelector(plotId) {
            const crops = await api('/api/configs/crops');
            const plotCfg = await api('/api/configs/plots/plot');
            document.getElementById('modal-title').textContent = text(plotCfg?.ui?.labels?.select_crop) || '–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ–º–µ–Ω–∞';
            document.getElementById('modal-footer').style.display = 'none';

            // Filter only crops that user has seeds for
            const availableCrops = Object.entries(crops || {}).filter(([code]) => {
                const seedCount = inventory[`seed_${code}`] || 0;
                return seedCount > 0;
            });

            if (availableCrops.length === 0) {
                document.getElementById('modal-body').innerHTML = `
                    <p style="color:#888;text-align:center;padding:30px">
                        –£ –≤–∞—Å –Ω–µ—Ç —Å–µ–º—è–Ω!<br><br>
                        <button onclick="closeModal(); showModal('shop')" style="padding:10px 20px;background:#4CAF50;color:white;border:none;border-radius:6px;cursor:pointer">
                            –ü–µ—Ä–µ–π—Ç–∏ –≤ –º–∞–≥–∞–∑–∏–Ω
                        </button>
                    </p>
                `;
            } else {
                document.getElementById('modal-body').innerHTML = `
                    <div class="shop-grid">
                        ${availableCrops.map(([code, c]) => {
                    const seedImg = c.stages?.seed?.image;
                    const iconHtml = seedImg
                        ? `<img src="${seedImg}">`
                        : 'üå±';
                    const seedCount = inventory[`seed_${code}`] || 0;
                    return `
                                <div class="shop-item" onclick="plantCrop(${plotId}, '${code}')">
                                    <span class="shop-item-qty">${seedCount}</span>
                                    <div class="shop-item-icon">${iconHtml}</div>
                                    <div class="shop-item-name">${text(c.name)}</div>
                                    <div class="shop-item-price">${seedCount} —Å–µ–º—è–Ω</div>
                                </div>
                            `;
                }).join('')}
                    </div>
                `;
            }
            document.getElementById('modal').classList.add('active');
        }

        async function plantCrop(plotId, cropCode) {
            closeModal();

            // Call API to plant crop (handles seeds, checkpoints, etc.)
            const response = await fetch(`${API_URL}/api/plant?plot_id=${plotId}&crop=${cropCode}`, {
                headers: { 'Authorization': tg?.initData || '' }
            });
            const result = await response.json();

            if (!result.success) {
                alert(result.error || '–û—à–∏–±–∫–∞ –ø–æ—Å–∞–¥–∫–∏');
                return;
            }

            // Reload inventory
            await loadInventory();

            // Update UI
            const cropCfg = await api(`/api/configs/crops/${cropCode}`);
            const plotEl = document.querySelector(`.plot[data-id="${plotId}"]`);
            const plantedAt = Date.now();

            // Get yield from server response or estimate from config
            const yieldAmount = result.yield || cropCfg?.products?.[0]?.yield?.[0] || 2;

            plots[plotId] = {
                state: 'planted',
                crop: cropCode,
                stage: 'seed',
                config: cropCfg,
                objectId: result.objectId,
                plantedAt: plantedAt,  // For countdown timer
                yieldAmount: yieldAmount  // For optimistic harvest
            };
            plotEl.classList.remove('empty');
            plotEl.classList.add('planted');

            const stageNames = { seed: '1/4', sprout: '2/4', growing: '3/4', ripe: '‚úì' };

            // Show initial seed stage image
            const img = cropCfg?.stages?.seed?.image;
            const html = img
                ? `<img src="${img}" class="crop-img">`
                : `<div class="crop-img" style="font-size:30px;text-align:center">üå±</div>`;
            plotEl.innerHTML = `${html}<span class="stage-indicator">${stageNames['seed']}</span>`;

            // Countdown timer will handle stage transitions automatically
            updatePlotTimer(plotId);
        }

        async function harvestCrop(plotId) {
            const plot = plots[plotId];
            if (!plot?.objectId) {
                console.log('[HARVEST] No objectId, cannot harvest');
                showToast('–û—à–∏–±–∫–∞: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ—Å–∞–¥–∫–µ', 'error');
                return;
            }

            const plotEl = document.querySelector(`.plot[data-id="${plotId}"]`);
            if (!plotEl) return;

            // Get plot config for empty image (cached or fetch)
            const emptyPlotImg = CONFIGS.plots?.plot?.stages?.empty?.image;

            // 1. SAVE STATE for potential rollback
            gameFSM.saveState(plots, inventory);
            const prevPlotState = JSON.parse(JSON.stringify(plot));

            // 2. PREDICT harvest amount (preloaded from DB or estimate from config)
            const yieldAmount = plot.yieldAmount || plot.config?.products?.[0]?.yield?.[0] || 2;
            const cropCode = plot.crop;
            const itemKey = `item_${cropCode}`;
            const cropIcon = plot.config?.stages?.ripe?.image ? 'üçé' : 'üì¶';

            // 3. OPTIMISTIC UPDATE - show immediately
            inventory[itemKey] = (inventory[itemKey] || 0) + yieldAmount;
            updateResourcesUI();

            // Show harvest animation with popup
            plotEl.classList.add('harvesting');
            plotEl.innerHTML = `<div class="harvest-popup">+${yieldAmount} ${cropIcon}</div>`;

            // Mark plot as empty optimistically
            plots[plotId] = { state: 'empty', crop: null, stage: 0, objectId: null, yieldAmount: null };

            // Clear plot visually after animation
            setTimeout(() => {
                plotEl.innerHTML = '';
                plotEl.classList.remove('planted', 'harvesting');
                plotEl.classList.add('empty');
                if (emptyPlotImg) {
                    plotEl.style.backgroundImage = `url('${emptyPlotImg}')`;
                }
            }, 1000);

            // 4. QUEUE ACTION for offline sync
            const actionId = gameFSM.queueAction({
                type: 'harvest',
                objectId: plot.objectId,
                plotId: plotId,
                expectedYield: yieldAmount,
                cropCode: cropCode
            });

            // 5. BACKGROUND REQUEST
            try {
                const response = await fetch(`${API_URL}/api/harvest?id=${plot.objectId}`, {
                    headers: { 'Authorization': tg?.initData || '' }
                });
                const result = await response.json();

                // Handle server errors (except withered which has special handling)
                if (result.error && result.error !== 'Withered') {
                    throw new Error(result.error);
                }

                // 6. SUCCESS - Complete the action
                gameFSM.completeAction(actionId);

                // Get actual yield from server
                const actualYield = result.harvested ?? yieldAmount;

                // Handle withered crops - already visually cleared, just adjust inventory
                if (result.error === 'Withered') {
                    console.log(`[HARVEST] Crop withered, adjusting inventory`);
                    // Remove the optimistically added items (crop is worthless)
                    inventory[itemKey] = Math.max(0, (inventory[itemKey] || 0) - yieldAmount);
                    updateResourcesUI();
                    showToast('–£—Ä–æ–∂–∞–π —É–≤—è–ª! ü•Ä', 'warning');
                    return;
                }

                // Adjust inventory if server value differs from prediction
                if (actualYield !== yieldAmount) {
                    const diff = actualYield - yieldAmount;
                    inventory[itemKey] = Math.max(0, (inventory[itemKey] || 0) + diff);
                    updateResourcesUI();
                    console.log(`[HARVEST] Adjusted yield: predicted ${yieldAmount}, actual ${actualYield}`);
                }

                console.log(`[HARVEST] Success: ${cropCode} x${actualYield}`);

            } catch (error) {
                console.error('[HARVEST] Error, rolling back:', error);

                // Check if offline - keep action queued for later sync
                if (!navigator.onLine) {
                    showToast('–û—Ñ—Ñ–ª–∞–π–Ω: —É—Ä–æ–∂–∞–π –±—É–¥–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω', 'warning');
                    // Keep action in queue, don't rollback visually
                    return;
                }

                // 7. ROLLBACK on error
                gameFSM.completeAction(actionId); // Remove failed action from queue
                const prevState = gameFSM.rollback();

                if (prevState) {
                    // Restore inventory
                    Object.assign(inventory, prevState.inventory);
                    updateResourcesUI();

                    // Restore plot state
                    plots[plotId] = prevPlotState;

                    // Restore visual
                    plotEl.classList.add('error');
                    setTimeout(() => {
                        restorePlotVisual(plotId, prevPlotState);
                        plotEl.classList.remove('error');
                    }, 500);
                }

                showToast(`–û—à–∏–±–∫–∞ —Å–±–æ—Ä–∞: ${error.message}`, 'error');
            }
        }


        async function showModal(type) {
            const cfg = await api(`/api/configs/ui/${type}`);
            document.getElementById('modal-title').textContent = text(cfg?.name) || type;
            document.getElementById('modal-footer').style.display = 'none';

            if (type === 'shop') {
                // Shop: buy seeds and animals
                const crops = await api('/api/configs/crops');
                const animals = await api('/api/configs/animals');

                let html = '<div style="padding:10px;"><h3 style="margin-bottom:10px;color:#5D4037;">üå± –°–µ–º–µ–Ω–∞</h3></div>';
                html += '<div class="shop-grid">';
                for (const [code, c] of Object.entries(crops || {})) {
                    const seedImg = c.stages?.seed?.image;
                    const iconHtml = seedImg ? `<img src="${seedImg}">` : 'üå±';
                    const owned = inventory[`seed_${code}`] || 0;
                    const isFree = c.buy_silver === 0;
                    html += `<div class="shop-item">
                        ${owned > 0 ? `<span class="shop-item-qty">${owned}</span>` : ''}
                        <div class="shop-item-icon">${iconHtml}</div>
                        <div class="shop-item-name">${text(c.name)}</div>
                        <div class="shop-item-price">${isFree ? '–ë–µ—Å–ø–ª–∞—Ç–Ω–æ' : c.buy_silver + ' ü™ô'}</div>
                        <div class="qty-selector">
                            <button onclick="changeQty('${code}', -1)">‚àí</button>
                            <input type="number" id="qty_${code}" value="1" min="1" max="99" readonly>
                            <button onclick="changeQty('${code}', 1)">+</button>
                        </div>
                        <button onclick="buySeeds('${code}', ${c.buy_silver})" style="margin-top:6px;width:100%;padding:6px;background:#4CAF50;color:white;border:none;border-radius:4px;cursor:pointer">
                            –ö—É–ø–∏—Ç—å
                        </button>
                    </div>`;
                }
                html += '</div>';

                html += '<div style="padding:10px;margin-top:20px;"><h3 style="margin-bottom:10px;color:#5D4037;">üêÑ –ñ–∏–≤–æ—Ç–Ω—ã–µ</h3></div>';
                html += '<div class="shop-grid">';
                for (const [code, c] of Object.entries(animals || {})) {
                    if (code === 'dog') continue; // Dog is special or handled elsewhere
                    const stageImg = c.stages?.fed?.image || c.icon;
                    const iconHtml = stageImg.startsWith('fsm/') || stageImg.startsWith('/')
                        ? `<img src="${stageImg}">`
                        : `<span style="font-size:40px">${stageImg}</span>`;

                    html += `<div class="shop-item">
                        <div class="shop-item-icon">${iconHtml}</div>
                        <div class="shop-item-name">${text(c.name)}</div>
                        <div class="shop-item-price">${c.buy_silver} ü™ô</div>
                        <button onclick="buyAnimal('${code}')" style="margin-top:6px;width:100%;padding:6px;background:#FF9800;color:white;border:none;border-radius:4px;cursor:pointer">
                            –ö—É–ø–∏—Ç—å
                        </button>
                    </div>`;
                }
                html += '</div>';
                document.getElementById('modal-body').innerHTML = html;

            } else if (type === 'warehouse') {
                // Warehouse: show items with total and sell all
                const crops = await api('/api/configs/crops');
                const animals = await api('/api/configs/animals');
                const factories = await api('/api/configs/factories');

                // Build item name lookup from ALL sources
                const itemNames = {};
                const itemConfigs = {};

                for (const [c, cfg] of Object.entries(crops || {})) {
                    itemNames[c] = cfg.name;
                    itemConfigs[c] = cfg;
                }
                for (const [a, cfg] of Object.entries(animals || {})) {
                    for (const p of cfg.products || []) {
                        itemNames[p.code] = p.name;
                        itemConfigs[p.code] = p;
                    }
                }
                for (const [f, cfg] of Object.entries(factories || {})) {
                    const fullCfg = await api(`/api/configs/factories/${f}`);
                    for (const p of fullCfg?.products || []) {
                        itemNames[p.code] = p.name;
                        itemConfigs[p.code] = p;
                    }
                }

                const items = Object.entries(inventory).filter(([k, v]) => k.startsWith('item_') && v > 0);

                if (items.length === 0) {
                    document.getElementById('modal-body').innerHTML = '<p style="color:#888;text-align:center;padding:40px">–°–∫–ª–∞–¥ –ø—É—Å—Ç</p>';
                } else {
                    let html = '<div class="shop-grid">';
                    let totalValue = 0;

                    for (const [key, qty] of items) {
                        const code = key.replace('item_', '');
                        const itemCfg = itemConfigs[code];
                        const ripeImg = itemCfg?.stages?.ripe?.image || itemCfg?.image;
                        const iconHtml = ripeImg ? `<img src="${ripeImg}">` : 'üì¶';
                        const sellPrice = itemCfg?.sell_silver || itemCfg?.products?.[0]?.sell_silver || 10;
                        totalValue += sellPrice * qty;

                        html += `<div class="shop-item">
                            <span class="shop-item-qty">${qty}</span>
                            <div class="shop-item-icon">${iconHtml}</div>
                            <div class="shop-item-name">${text(itemNames[code]) || code}</div>
                            <div class="shop-item-price">${sellPrice} ü™ô / —à—Ç</div>
                            <div class="qty-selector">
                                <button onclick="changeSellQty('${code}', -1, ${qty})">‚àí</button>
                                <input type="number" id="sell_${code}" value="${qty}" min="1" max="${qty}" readonly>
                                <button onclick="changeSellQty('${code}', 1, ${qty})">+</button>
                            </div>
                            <button onclick="sellItems('${code}', ${sellPrice})" style="margin-top:6px;width:100%;padding:6px;background:#FF9800;color:white;border:none;border-radius:4px;cursor:pointer">
                                –ü—Ä–æ–¥–∞—Ç—å
                            </button>
                        </div>`;
                    }
                    html += '</div>';
                    document.getElementById('modal-body').innerHTML = html;

                    // Show footer with total and sell all button
                    document.getElementById('modal-footer').style.display = 'flex';
                    document.getElementById('modal-total').textContent = totalValue.toLocaleString();
                    document.getElementById('modal-action-btn').textContent = '–ü—Ä–æ–¥–∞—Ç—å –≤—Å—ë';
                    document.getElementById('modal-action-btn').onclick = () => confirmSellAll(totalValue);
                }

            } else if (type === 'friends') {
                document.getElementById('modal-body').innerHTML = '<p style="color:#888;text-align:center;padding:40px">–î—Ä—É–∑—å—è —Å–∫–æ—Ä–æ –ø–æ—è–≤—è—Ç—Å—è!</p>';

            } else if (type === 'settings') {
                document.getElementById('modal-body').innerHTML = `
                    <div style="padding:20px">
                        <p><b>–Ø–∑—ã–∫:</b> –†—É—Å—Å–∫–∏–π</p>
                        <p><b>–ó–≤—É–∫–∏:</b> –í–∫–ª</p>
                    </div>
                `;
            } else {
                document.getElementById('modal-body').innerHTML = `<p style="padding:20px">${text(cfg?.description) || ''}</p>`;
            }
            document.getElementById('modal').classList.add('active');
        }

        // Quantity helpers
        function changeQty(code, delta) {
            const input = document.getElementById(`qty_${code}`);
            const newVal = Math.max(1, Math.min(99, parseInt(input.value) + delta));
            input.value = newVal;
        }

        function changeSellQty(code, delta, max) {
            const input = document.getElementById(`sell_${code}`);
            const newVal = Math.max(1, Math.min(max, parseInt(input.value) + delta));
            input.value = newVal;
        }

        // Buy seeds with quantity
        async function buySeeds(cropCode, pricePerUnit) {
            const qty = parseInt(document.getElementById(`qty_${cropCode}`)?.value || 1);
            const totalPrice = pricePerUnit * qty;

            if (totalPrice > 0 && (inventory.silver || 0) < totalPrice) {
                alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!');
                return;
            }

            if (totalPrice > 0) {
                await modifyStat('silver', -totalPrice);
            }
            await modifyStat(`seed_${cropCode}`, qty);
            updateResourcesUI();
            showModal('shop'); // Refresh
        }

        // Sell items with quantity
        async function sellItems(itemCode, pricePerUnit) {
            const qty = parseInt(document.getElementById(`sell_${itemCode}`)?.value || 1);
            const key = `item_${itemCode}`;

            if ((inventory[key] || 0) < qty) {
                alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–≤–∞—Ä–∞!');
                return;
            }

            await modifyStat(key, -qty);
            await modifyStat('silver', pricePerUnit * qty);
            updateResourcesUI();
            showModal('warehouse'); // Refresh
        }

        // Confirm sell all
        function confirmSellAll(totalValue) {
            document.getElementById('submodal-title').textContent = '–ü—Ä–æ–¥–∞—Ç—å —Ç–æ–≤–∞—Ä—ã';
            document.getElementById('submodal-text').textContent = `–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–∞—Ç—å –≤—Å–µ —Ç–æ–≤–∞—Ä—ã —Å–æ —Å–∫–ª–∞–¥–∞ –∑–∞ ${totalValue.toLocaleString()} ü™ô?`;
            document.getElementById('submodal-ok').onclick = async () => {
                await sellAllItems();
                closeSubmodal();
            };
            document.getElementById('submodal').classList.add('active');
        }

        async function sellAllItems() {
            const crops = await api('/api/configs/crops');
            const items = Object.entries(inventory).filter(([k, v]) => k.startsWith('item_') && v > 0);

            for (const [key, qty] of items) {
                const code = key.replace('item_', '');
                const cropCfg = crops?.[code];
                const sellPrice = cropCfg?.sell_silver || cropCfg?.products?.[0]?.sell_silver || 10;

                await modifyStat(key, -qty);
                await modifyStat('silver', sellPrice * qty);
            }

            updateResourcesUI();
            showModal('warehouse');
        }

        function closeSubmodal() {
            document.getElementById('submodal').classList.remove('active');
        }

        window.changeQty = changeQty;
        window.changeSellQty = changeSellQty;
        window.buySeeds = buySeeds;
        window.sellItems = sellItems;
        window.confirmSellAll = confirmSellAll;
        window.closeSubmodal = closeSubmodal;

        // Buy seed
        async function buySeed(cropCode, price) {
            if ((inventory.silver || 0) < price) {
                alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!');
                return;
            }
            await modifyStat('silver', -price);
            await modifyStat(`seed_${cropCode}`, 1);
            updateResourcesUI();
            showModal('shop'); // Refresh
        }

        // Sell item from warehouse
        async function sellItem(itemCode, qty, pricePerUnit) {
            const key = `item_${itemCode}`;
            if ((inventory[key] || 0) < qty) {
                alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–≤–∞—Ä–∞!');
                return;
            }
            await modifyStat(key, -qty);
            await modifyStat('silver', pricePerUnit * qty);
            updateResourcesUI();
            showModal('warehouse'); // Refresh
        }

        window.buySeed = buySeed;
        window.sellItem = sellItem;

        function closeModal() { document.getElementById('modal').classList.remove('active'); }

        init();
    </script>
</body>

</html>